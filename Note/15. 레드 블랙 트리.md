## 레드 블랙 트리

- 이진 탐색 트리의 한 종류로, 고유한 규칙을 통해 균형을 유지하여 탐색, 삽입, 삭제 연산의 시간 복잡도를 O(logN)으로 보장
- 레드 블랙 트리의 다섯가지 규칙
    1. 모든 노드는 **빨강(Red)** 또는 **검정(Black)**
    2. 루트 노드는 검정
    3. 모든 리프 노드(NIL)는 검정
    4. 빨강 노드의 자식은 모두 검정(빨간 노드가 연속할 수 없음) 
    5. (본인 제외) 루트에서 임의 리프 노드까지  경로에 검정 노드 수는 모두 같음

- 노드가 삽입/삭제할 때마다 트리가 규칙을 지키는지 검사하고 규칙이 깨질 경우 색을 바꾸거나 **회전(rotation)** 연산
    - 회전 연산
        
        ```c++
        void RedBlackTree::RotateToRight(Node* node)
        {
        	/*
        	* befor)
        	*		X
        	*	   /
        	*	  Y
        	*	 / \
        	*	A   B
        	*
        	* after)
        	*	  Y
        	*	 / \
        	*	A   X
        	*	   /
        	*	  B
        	*/
        
        	// 1. (부모가 될) 자손 노드의 자식 노드 정리
        	/*
        	*  Y			X
        	*   \	->	   /
        	*	 B		  B
        	*/
        
        	// Y (왼쪽 자식)
        	Node* left = node->GetLeft();
        
        	// 1. Y의 오른쪽 자식(B)을 X(부모)의 왼쪽 자식으로 연결
        	node->SetLeft(left->GetRight());
        	if (left->GetRight() != nil)
        	{
        		left->GetRight()->SetParent(node);
        	}
        
        	// 2. Y의 부모를 X의 부모와 연결
        	Node* grandParent = node->GetParent();
        	left->SetParent(grandParent);
        
        	// 1) 조부모가 없음 (원래 부모가 root 인 경우)
        	if (grandParent == nullptr)
        	{
        		// root 변경
        		root = left;
        	}
        	// 2) 조부모가 있음
        	else
        	{
        		// X가 부모의 왼쪽 자식이었으면, Y를 부모의 왼쪽 자식으로
        		if (node == node->GetParent()->GetLeft())
        		{
        			node->GetParent()->SetLeft(left);
        		}
        		// X가 부모의 오른쪽 자식이었으면, Y를 부모의 오른쪽 자식으로
        		else
        		{
        			node->GetParent()->SetRight(left);
        		}
        	}
        
        	// 3. Y를 X의 부모로, X를 Y의 오른쪽 자식으로 연결
        
        	// 원래 부모를 오른쪽 자손으로
        	left->SetRight(node);
        
        	// 원래 부모의 부모 재설정
        	node->SetParent(left);
        }
        
        void RedBlackTree::PrintRecursive(Node* node, int depth, int blackCount)
        {
        	// 탈출 조건.
        	if (node == nil)
        	{
        		return;
        	}
        
        	// 노드 색상이 검정이면 blackCount 증가.
        	if (node->GetColor() == Color::Black)
        	{
        		++blackCount;
        	}
        
        	// 부모 표기 문자열 설정.
        	int parentData = 0;
        	const char* position = "Root";
        
        	// 부모 노드가 있는지 확인.
        	if (node->GetParent())
        	{
        		// 부모 노드의 데이터 저장.
        		parentData = node->GetParent()->GetData();
        
        		// 부모 노드로부터 현재 노드의 위치 설정.
        		if (node == node->GetParent()->GetLeft())
        		{
        			position = "Left";
        		}
        		else
        		{
        			position = "Right";
        		}
        	}
        
        	// 검은색 수 출력을 위한 문자열.
        	char blackCountString[50] = { };
        
        	// 자손이 없으면 현재까지의 검은색 노드 수 설정.
        	if (node->GetLeft() == nil && node->GetRight() == nil)
        	{
        		sprintf_s(blackCountString, "------ %d", blackCount);
        	}
        
        	// Depth 출력.
        	for (int ix = 0; ix < depth; ++ix)
        	{
        		std::cout << "  ";
        	}
        
        	// 노드 색상에 따른 콘솔 설정.
        	if (node->GetColor() == Color::Red)
        	{
        		SetTextColor(TextColor::Red);
        	}
        	else
        	{
        		SetTextColor(TextColor::White);
        	}
        
        	// 현재 노드 값 출력.
        	std::cout
        		<< node->GetData() << " "
        		<< node->GetColorString() << " ["
        		<< position << ", "
        		<< parentData << "] "
        		<< blackCountString << "\n";
        
        	// 노드를 출력한 뒤에는 콘솔 원래대로.
        	SetTextColor(TextColor::White);
        
        	// 하위 노드 출력.
        	PrintRecursive(node->GetLeft(), depth + 1, blackCount);
        	PrintRecursive(node->GetRight(), depth + 1, blackCount);
        }
        ```
