# 복습

### 퀵 정렬(Quick Sort)

- **설명**: 기준 원소(Pivot)를 선택하여 작은 값과 큰 값으로 나누는 과정을 반복하여 정렬(분할 정복)
- **평가**: 평균적으로 빠르나, 최악의 경우 $O(n^2)$이 될 수 있어 적절한 기준 원소 선택이 중요합니다.
    - **시간 복잡도**: 평균 및 최선의 경우 $O(n\log n)$, 최악의 경우  $O(n^2)$
    - **안정성**: 불안정 (Unstable)
- **의사 코드**
    
    ```c
    // 퀵 정렬 메인 함수
    procedure quick_sort(list, start, end)
        if start < end then
            pivot_index = partition(list, start, end)
            call quick_sort(list, start, pivot_index - 1)
            call quick_sort(list, pivot_index + 1, end)
    ```
    
    - **호어(Hoare) 파티션**: 양 끝에서 두 개의 포인터(`low`와 `high`)가 서로를 향해 이동하며 피벗보다 작은 값과 큰 값을 교환. 분할이 끝나면 `low`와 `high`가 교차하는 지점에서 멈춤
        
        ```c
        procedure Hoare_partition(array, left, right)
            pivot = array[left]
            low = left - 1
            high = right + 1
            
            while true
        		    // 피벗보다 크거나 같은 값 찾기
                do 
                    low = low + 1
                while array[low] < pivot
        
        				// 피벗보다 작거나 같은 값 찾기
                do 
                    high = high - 1
                while array[high] > pivot
        
                // 포인터가 교차하면 분할 완료
                if low >= high then
                    return high
        
                // 교차하지 않았다면 두 값을 교환
                swap(array[low], array[high])
        ```
        

### 병합 정렬(Merge Sort)

- **설명**: 배열을 재귀적으로 나누고, 정렬된 하위 배열들을 병합하여 전체를 정렬
- **평가**: 데이터의 크기와 상관없이 일정한 시간 복잡도를 보장. 하지만 정렬 과정에서 임시 배열을 사용하므로 추가적인 메모리 공간이 필요
    - **시간 복잡도**:  $O(n\log n)$
    - **공간 복잡도**: $O(n)$
    - **안정성**: 안정적 (Stable)
- **의사 코드**
    
    ```c
    procedure merge_sort(list)
    		// base case
        if length(list) <= 1
            return list
      
        // 1. 분할(Split)
        mid = length(list) / 2
        left = list[0...mid-1]
        right = list[mid...end]
        
        // 2. 재귀(Recurse)
        left = merge_sort(left)
        right = merge_sort(right)
        
        // 3. 병합(Merge)
        return merge(left, right)
    
    procedure merge(left, right)
        result = empty_list
        // 왼쪽, 오른쪽 두 배열 원소 비교
        while left is not empty and right is not empty
            if first(left) <= first(right)
                append first(left) to result
                remove first from left
            else
                append first(right) to result
                remove first from right
        
        // 왼쪽 나머지
        while left is not empty
            append all from left to result
        // 오른쪽 나머지
        while right is not empty
            append all from right to result
            
        return result
    ```
