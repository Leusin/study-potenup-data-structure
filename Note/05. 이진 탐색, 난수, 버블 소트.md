## 이진 탐색

- 정렬된 배열에서 중간 값을 비교하고 찾지 못하면 절반으로 탐색 범위를 줄여나가는 탐색 알고리즘
- 재귀적 방식 또는 반복적 방식으로 구현
- 매 단계 탐색 범위를 절반으로 줄기 때문에 로그 시간 복잡도(O(log n))를 가지나 데이터가 미리 정렬되어 있어야 한다는 한계가 있음

## 난수

- 컴퓨터가 생성하는 난수는 대부분 **의사 난수(Pseudorandom Number).**
- **선형 합동(Linear Congruency)**: 종자 값을 이용한 일련의 수학적 계산(알고리즘)을 통해 난수 생성. 시작점인 **종자 값(seed)**이 같으면 항상 동일한 시퀀스를 생성
- **선형(균등 분포)**: 결과 값이 특정 범위 내에서 고르게 분포

    <img width="261" height="311" alt="Image" src="https://github.com/user-attachments/assets/03d64528-364f-4c73-b396-78f829a27c3d" />

### 정수 난수

- 나머지(모듈러 연산)을 이용
    
    ```cpp
    int RandomRange(int min, int max)
    {
    	int diff = (max - min) + 1;
    	return (rand() % diff) + min;
    }
    ```
    
    - `rand()` 의 최대값 `RAND_MAX` 가 `diff` 로 나누어떨어지지 않을 경우, 일부 숫자가 다른 숫자보다 나올 확률이 높아져 균등 분포가 깨질 수 있음
    - `rand()` 의 상위 비트를 자르기 때문에 난수 주기가 짧아질 수 있음
- 나누기를 이용하는 방법
    
    ```cpp
    int RandomRange(int min, int max)
    {
    	int diff = (max - min) + 1;
    	return ((diff * rand()) / (RAND_MAX + 1)) + min;
    }
    ```
    
    - 전체 범위(0 ~ `RAND_MAX`)를 활용하여 보다 균등한 분포를 얻음

### 부동 소수점 난수

- 0 ~ 1 사이 난수 생성
    
    ```cpp
    float RandomPercent()
    {
    	return static_cast<float>(rand()) / static_cast<float>(RAND_MAX);
    }
    ```
    
- 특정 범위로 확장
    
    ```cpp
    float RandomRange(float min, float max)
    {
    	float diff = (max - min);
    	return (RandomPercent() * diff) + min;
    }
    ```
    

### 비선형 난수

- 균등하지 않은 분포를 따르는 난수
- 두 난수를 더하는 방법
    
    ```cpp
    // x의 범위는 0-8
    int x = RandomRange(0, 4) + RandomRange(0, 4);
    ```
    
    - 가운데 숫자(4)가 가장 많이 나오는 분포
 
        <img width="319" height="253" alt="Image" src="https://github.com/user-attachments/assets/1d52b5fc-9d6a-425e-bd24-01a1d9ba83b9" />
        
- 세 난수를 더하는 방법
    
    ```cpp
    // x의 범위는 0-9
    int x = RandomRange(0, 3) + RandomRange(0, 3) + RandomRange(0, 3);
    ```
    
    - 종 모양 곡선(정규 분포)에 가까운 모양
 
        <img width="337" height="268" alt="Image" src="https://github.com/user-attachments/assets/19487d75-e5d3-47ec-8b36-57cdbc797b30" />

## 버블 소트

- 배열 처음부터 끝까지 인접한 원소와 비교하는 과정을 반복하는 정렬
- 구현이 간단하지만 매우 비효율적인 정렬 알고리즘(O(n^2))
- 의사코드
    
    ```cpp
    // https://www.toptal.com/developers/sorting-algorithms/bubble-sort
    for i = 1:n,
        swapped = false
        for j = n:i+1,
            if a[j] < a[j-1],
                swap a[j,j-1]
                swapped = true
        → invariant: a[1..i] in final position
        break if not swapped
    end
    ```
